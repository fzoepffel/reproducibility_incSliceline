# experiment 2 measures the execution time of the incremental slice line algorithm 
# for 10 iterations with increasingly large input feature matrices 
# while keeping the proportion of addedX/totalX the same over all iterations  (see SlicingExp2.dml)
# the execution is also measured for the slicefinder algorithm for the same input matrices (see SlicingExp2b.dml)

X = read($1);
e = read($2);
sigma = $3;
iteration = $4;

X = X[, 1:8];

numOfPoints = 10;
totalDataPoints = 100;  # 10 iterations * 10 data points

# Set up the log scale from 15 to nrow(X) over 100 points
minRows = 15;
maxRows = nrow(X);
logScale = matrix(0, totalDataPoints, 1);
for(i in 1:totalDataPoints) {
    logScale[i, 1] = exp(log(minRows) + (i - 1) * (log(maxRows) - log(minRows)) / (totalDataPoints - 1));
}

# Get the starting index for this iteration
startIndex = (iteration - 1) * numOfPoints + 1;


for( i in 1: (numOfPoints)){
    # Determine the total number of rows for X2 based on the log scale for the current data point
    nTotalRows = floor(as.scalar(logScale[startIndex + i - 1, 1]));

    # Select the first nTotalRows of X2
    X2 = X[1:nTotalRows,  ];
    e2 = e[1:nTotalRows,  ];

    # run once to warm up the system
    [S,C,D] = slicefinder(X=X2, e=e2, k=10, alpha=0.95, minSup=sigma, tpBlksz=16, verbose=TRUE);

    timeTaken = 0;
    for(j in 1: 10){
        start = time();
        [S,C,D] = slicefinder(X=X2, e=e2, k=10, alpha=0.95, minSup=sigma, tpBlksz=16, verbose=TRUE);
        end = time()

        timeTaken = timeTaken + (((end-start) / 1000000  ));
    }

    timeTaken = timeTaken / 10;
    write(timeTaken, "results/Experiment4_timesSF"+ "_Prop"+ propStr+ "_" + (numOfPoints*iteration + i)+".dat", format="csv")
}


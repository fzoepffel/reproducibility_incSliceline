# experiment 2 measures the execution time of the incremental slice line algorithm 
# for 10 iterations with increasingly large input feature matrices 
# while keeping the proportion of addedX/totalX the same over all iterations  (see SlicingExp2.dml)
# the execution is also measured for the slicefinder algorithm for the same input matrices (see SlicingExp2b.dml)

X = read($1);
e = read($2);
sigma = $3;
iteration = $4;

X = X[, 1:8];

numOfPoints = 10;

nTotalRows = nrow(X);

proportion = 0;
propStr = 0;

propVal = $5;

if(propVal == 1){
    proportion = 0.01;
    propStr = 1;
}

if(propVal == 2){
    proportion = 0.1;
    propStr = 10;
}

if(propVal == 3){
    proportion = 0.3;
    propStr = 50;
}

decrease = 1 - proportion;
nTotalRows = nrow(X) * (decrease^(numOfPoints*(10-iteration)));
oldX = X[1:floor(nTotalRows * (decrease^numOfPoints)) ,  ]
oldE = e[1:floor(nTotalRows * (decrease^numOfPoints)) ,] 

X2 = oldX;
e2 = oldE;

for( i in 1: (numOfPoints)){
    addedX = X[floor(nTotalRows * (decrease ^ ((numOfPoints +1) -i))) +1 : floor(nTotalRows * (decrease ^ (numOfPoints -i))),  ]
    addedE = e[floor(nTotalRows * (decrease ^ ((numOfPoints +1) -i))) +1 : floor(nTotalRows * (decrease ^ (numOfPoints -i))), ]

    X2 = rbind(X2, addedX);
    e2 = rbind(e2, addedE);

    # run twice to warm up the system
    [S,C,D] = slicefinder(X=X2, e=e2, k=10, alpha=0.95, minSup=sigma, tpBlksz=16, verbose=TRUE);
    [S,C,D] = slicefinder(X=X2, e=e2, k=10, alpha=0.95, minSup=sigma, tpBlksz=16, verbose=TRUE);

    timeTaken = 0;
    for(j in 1: 10){
        start = time();
        [S,C,D] = slicefinder(X=X2, e=e2, k=10, alpha=0.95, minSup=sigma, tpBlksz=16, verbose=TRUE);
        end = time()

        timeTaken = timeTaken + (((end-start) / 1000000  ));
    }

    timeTaken = timeTaken / 10;
    write(timeTaken, "results/Experiment4_timesSF"+ "_Prop"+ propStr+ "_" + (numOfPoints*iteration + i)+".dat", format="csv")
}

